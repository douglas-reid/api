// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tracing/v1alpha1/tracing.proto

/*
Package v1alpha1 is a generated protocol buffer package.

Provides configuration parameters for Istio tracing.

It is generated from these files:
	tracing/v1alpha1/tracing.proto

It has these top-level messages:
	TracingConfiguration
	TraceCollector
	ZipkinCollector
	Percent
	TraceSampling
*/
package v1alpha1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// TracingConfiguration controls Istio-wide trace collection configuration
// parameters. It includes the configuration for the tracing backends as well
// as the rates at which distributed tracing data should be generated.
//
// Example configuration:
// ```yaml
// apiVersion: tracing.istio.io/v1alpha1
// kind: TracingConfiguration
// metadata:
//   name: meshwide
// spec:
//   traceCollector:
//     zipkinCollector:
//       address: zipkin:9411
// ```
//
// WARNING: This is not currently supported by Istio.
type TracingConfiguration struct {
	// Provides configuration for a tracing backend
	TraceCollector *TraceCollector `protobuf:"bytes,1,opt,name=trace_collector,json=traceCollector" json:"trace_collector,omitempty"`
	// $hide_from_docs
	//
	// Controls the rate of trace generation.
	//
	// NOTE: This will only be effective when support for Envoy V2 APIs is added
	// to Istio Pilot.
	TraceSampling *TraceSampling `protobuf:"bytes,2,opt,name=trace_sampling,json=traceSampling" json:"trace_sampling,omitempty"`
}

func (m *TracingConfiguration) Reset()                    { *m = TracingConfiguration{} }
func (m *TracingConfiguration) String() string            { return proto.CompactTextString(m) }
func (*TracingConfiguration) ProtoMessage()               {}
func (*TracingConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TracingConfiguration) GetTraceCollector() *TraceCollector {
	if m != nil {
		return m.TraceCollector
	}
	return nil
}

func (m *TracingConfiguration) GetTraceSampling() *TraceSampling {
	if m != nil {
		return m.TraceSampling
	}
	return nil
}

// TraceCollector holds the configuration for a specific tracing backend.
type TraceCollector struct {
	// Types that are valid to be assigned to Collector:
	//	*TraceCollector_ZipkinCollector
	Collector isTraceCollector_Collector `protobuf_oneof:"collector"`
}

func (m *TraceCollector) Reset()                    { *m = TraceCollector{} }
func (m *TraceCollector) String() string            { return proto.CompactTextString(m) }
func (*TraceCollector) ProtoMessage()               {}
func (*TraceCollector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isTraceCollector_Collector interface{ isTraceCollector_Collector() }

type TraceCollector_ZipkinCollector struct {
	ZipkinCollector *ZipkinCollector `protobuf:"bytes,1,opt,name=zipkin_collector,json=zipkinCollector,oneof"`
}

func (*TraceCollector_ZipkinCollector) isTraceCollector_Collector() {}

func (m *TraceCollector) GetCollector() isTraceCollector_Collector {
	if m != nil {
		return m.Collector
	}
	return nil
}

func (m *TraceCollector) GetZipkinCollector() *ZipkinCollector {
	if x, ok := m.GetCollector().(*TraceCollector_ZipkinCollector); ok {
		return x.ZipkinCollector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TraceCollector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TraceCollector_OneofMarshaler, _TraceCollector_OneofUnmarshaler, _TraceCollector_OneofSizer, []interface{}{
		(*TraceCollector_ZipkinCollector)(nil),
	}
}

func _TraceCollector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TraceCollector)
	// collector
	switch x := m.Collector.(type) {
	case *TraceCollector_ZipkinCollector:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ZipkinCollector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TraceCollector.Collector has unexpected type %T", x)
	}
	return nil
}

func _TraceCollector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TraceCollector)
	switch tag {
	case 1: // collector.zipkin_collector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZipkinCollector)
		err := b.DecodeMessage(msg)
		m.Collector = &TraceCollector_ZipkinCollector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TraceCollector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TraceCollector)
	// collector
	switch x := m.Collector.(type) {
	case *TraceCollector_ZipkinCollector:
		s := proto.Size(x.ZipkinCollector)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Configuration for a Zipkin collector.
type ZipkinCollector struct {
	// Required. Address of the Zipkin service (e.g. _zipkin:9411_).
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Optional. API endpoint of the Zipkin service.
	//
	// Default: "/api/v1/spans"
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint" json:"endpoint,omitempty"`
}

func (m *ZipkinCollector) Reset()                    { *m = ZipkinCollector{} }
func (m *ZipkinCollector) String() string            { return proto.CompactTextString(m) }
func (*ZipkinCollector) ProtoMessage()               {}
func (*ZipkinCollector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ZipkinCollector) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ZipkinCollector) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

// Identifies a percentage.
type Percent struct {
	// Valid range: `[0.0, 100.0]`
	Value float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
}

func (m *Percent) Reset()                    { *m = Percent{} }
func (m *Percent) String() string            { return proto.CompactTextString(m) }
func (*Percent) ProtoMessage()               {}
func (*Percent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Percent) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// $hide_from_docs
//
// Controls the rate at which Istio will generate trace spans for requests
// within a mesh. Sampling can be controlled in one of two ways: client-directed
// and random sampling. Client-directed sampling refers to sampling based on
// values of HTTP headers set by requesting clients. Random sampling refers to
// the process of selecting a request for tracing based on a randomly generated
// request ID. It is also possible to set an upper limit on the rate of all
// trace sampling, via control of the overall sampling rate.
type TraceSampling struct {
	// Target percentage of requests that will be force traced if the
	// x-client-trace-id header is set by the client of a request.
	//
	// Default: 0.0%
	ClientSampling *Percent `protobuf:"bytes,1,opt,name=client_sampling,json=clientSampling" json:"client_sampling,omitempty"`
	// Target percentage of requests managed that will be randomly selected for
	// trace generation, if not requested by the client.
	//
	// Default: 0.0%
	RandomSampling *Percent `protobuf:"bytes,2,opt,name=random_sampling,json=randomSampling" json:"random_sampling,omitempty"`
	// Target percentage of requests that will be traced after all other
	// sampling checks have been applied (client-directed, random sampling).
	// This field functions as an upper limit on the total configured sampling
	// rate. For instance, setting `client_sampling` to 100% and `overall_sampling`
	// to 1% will result in only 1% of client requests with the appropriate
	// headers to be force traced.
	//
	// Default: 0.0%
	OverallSampling *Percent `protobuf:"bytes,3,opt,name=overall_sampling,json=overallSampling" json:"overall_sampling,omitempty"`
}

func (m *TraceSampling) Reset()                    { *m = TraceSampling{} }
func (m *TraceSampling) String() string            { return proto.CompactTextString(m) }
func (*TraceSampling) ProtoMessage()               {}
func (*TraceSampling) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TraceSampling) GetClientSampling() *Percent {
	if m != nil {
		return m.ClientSampling
	}
	return nil
}

func (m *TraceSampling) GetRandomSampling() *Percent {
	if m != nil {
		return m.RandomSampling
	}
	return nil
}

func (m *TraceSampling) GetOverallSampling() *Percent {
	if m != nil {
		return m.OverallSampling
	}
	return nil
}

func init() {
	proto.RegisterType((*TracingConfiguration)(nil), "istio.tracing.v1alpha1.TracingConfiguration")
	proto.RegisterType((*TraceCollector)(nil), "istio.tracing.v1alpha1.TraceCollector")
	proto.RegisterType((*ZipkinCollector)(nil), "istio.tracing.v1alpha1.ZipkinCollector")
	proto.RegisterType((*Percent)(nil), "istio.tracing.v1alpha1.Percent")
	proto.RegisterType((*TraceSampling)(nil), "istio.tracing.v1alpha1.TraceSampling")
}

func init() { proto.RegisterFile("tracing/v1alpha1/tracing.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 338 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xcf, 0x4e, 0xf2, 0x40,
	0x14, 0xc5, 0xbf, 0x7e, 0x46, 0x91, 0x4b, 0xa0, 0x64, 0x42, 0x0c, 0x31, 0x51, 0x4c, 0x13, 0xff,
	0xac, 0xda, 0xa0, 0x6f, 0x00, 0x0b, 0x89, 0x31, 0xd1, 0x8c, 0xac, 0xd8, 0x90, 0xb1, 0x1d, 0xf1,
	0xc6, 0x61, 0xa6, 0x99, 0x0e, 0x2c, 0x78, 0x2f, 0x9f, 0xcb, 0x57, 0x30, 0x74, 0xda, 0x42, 0xab,
	0xa8, 0xcb, 0x73, 0x72, 0xce, 0xef, 0xf6, 0x76, 0x2e, 0x9c, 0x1a, 0xcd, 0x42, 0x94, 0xb3, 0x60,
	0xd9, 0x67, 0x22, 0x7e, 0x65, 0xfd, 0x20, 0x33, 0xfc, 0x58, 0x2b, 0xa3, 0xc8, 0x11, 0x26, 0x06,
	0x95, 0x9f, 0x9b, 0x79, 0xca, 0x7b, 0x77, 0xa0, 0x33, 0xb6, 0xe6, 0x50, 0xc9, 0x17, 0x9c, 0x2d,
	0x34, 0x33, 0xa8, 0x24, 0x79, 0x00, 0x77, 0x1d, 0xe6, 0xd3, 0x50, 0x09, 0xc1, 0x43, 0xa3, 0x74,
	0xd7, 0x39, 0x73, 0xae, 0x1a, 0xd7, 0x17, 0xfe, 0xf7, 0x28, 0x7f, 0x8d, 0xe1, 0xc3, 0x3c, 0x4d,
	0x5b, 0xa6, 0xa4, 0xc9, 0x3d, 0x58, 0x67, 0x9a, 0xb0, 0x79, 0x2c, 0x50, 0xce, 0xba, 0xff, 0x53,
	0xde, 0xf9, 0x8f, 0xbc, 0xa7, 0x2c, 0x4c, 0x9b, 0x66, 0x5b, 0x7a, 0x09, 0xb4, 0xca, 0xf3, 0xc8,
	0x18, 0xda, 0x2b, 0x8c, 0xdf, 0x50, 0x7e, 0xf9, 0xe2, 0xcb, 0x5d, 0x13, 0x26, 0x69, 0xbe, 0x40,
	0x8c, 0xfe, 0x51, 0x77, 0x55, 0xb6, 0x06, 0x0d, 0xa8, 0x17, 0x38, 0xef, 0x16, 0xdc, 0x4a, 0x85,
	0x74, 0xa1, 0xc6, 0xa2, 0x48, 0xf3, 0x24, 0x49, 0x87, 0xd5, 0x69, 0x2e, 0xc9, 0x31, 0x1c, 0x72,
	0x19, 0xc5, 0x0a, 0xa5, 0x49, 0x37, 0xad, 0xd3, 0x42, 0x7b, 0x3d, 0xa8, 0x3d, 0x72, 0x1d, 0x72,
	0x69, 0x48, 0x07, 0xf6, 0x97, 0x4c, 0x2c, 0x78, 0x5a, 0x77, 0xa8, 0x15, 0xde, 0x87, 0x03, 0xcd,
	0xd2, 0xfe, 0x64, 0x04, 0x6e, 0x28, 0x90, 0x4b, 0xb3, 0xf9, 0x7f, 0x76, 0xbb, 0xde, 0xae, 0xed,
	0xb2, 0x09, 0xb4, 0x65, 0x7b, 0xdb, 0x24, 0xcd, 0x64, 0xa4, 0xe6, 0xd5, 0x97, 0xf8, 0x9d, 0x64,
	0x7b, 0x05, 0xe9, 0x0e, 0xda, 0x6a, 0xc9, 0x35, 0x13, 0x62, 0x83, 0xda, 0xfb, 0x1b, 0xca, 0xcd,
	0x8a, 0x39, 0x6b, 0xd0, 0x9b, 0x9c, 0xd8, 0x0a, 0xaa, 0x80, 0xc5, 0x18, 0x54, 0xef, 0xf9, 0xf9,
	0x20, 0x3d, 0xe4, 0x9b, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x7f, 0x15, 0x67, 0xea, 0x02,
	0x00, 0x00,
}
