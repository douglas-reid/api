// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry/v1alpha1/telemetry.proto

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	v1beta1 "istio.io/api/type/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Curated list of known metric types that is supported by all metric providers.
type MetricsOverrides_StandardMetric int32

const (
	MetricsOverrides_ALL_METRICS            MetricsOverrides_StandardMetric = 0
	MetricsOverrides_REQUEST_COUNT          MetricsOverrides_StandardMetric = 1
	MetricsOverrides_REQUEST_DURATION       MetricsOverrides_StandardMetric = 2
	MetricsOverrides_REQUEST_SIZE           MetricsOverrides_StandardMetric = 3
	MetricsOverrides_RESPONSE_SIZE          MetricsOverrides_StandardMetric = 4
	MetricsOverrides_TCP_OPEN_CONNECTIONS   MetricsOverrides_StandardMetric = 5
	MetricsOverrides_TCP_CLOSED_CONNECTIONS MetricsOverrides_StandardMetric = 6
	MetricsOverrides_TCP_SENT_BYTES         MetricsOverrides_StandardMetric = 7
	MetricsOverrides_TCP_RECEIVED_BYTES     MetricsOverrides_StandardMetric = 8
	MetricsOverrides_GRPC_REQUEST_MESSAGES  MetricsOverrides_StandardMetric = 9
	MetricsOverrides_GRPC_RESPONSE_MESSAGES MetricsOverrides_StandardMetric = 10
)

var MetricsOverrides_StandardMetric_name = map[int32]string{
	0:  "ALL_METRICS",
	1:  "REQUEST_COUNT",
	2:  "REQUEST_DURATION",
	3:  "REQUEST_SIZE",
	4:  "RESPONSE_SIZE",
	5:  "TCP_OPEN_CONNECTIONS",
	6:  "TCP_CLOSED_CONNECTIONS",
	7:  "TCP_SENT_BYTES",
	8:  "TCP_RECEIVED_BYTES",
	9:  "GRPC_REQUEST_MESSAGES",
	10: "GRPC_RESPONSE_MESSAGES",
}

var MetricsOverrides_StandardMetric_value = map[string]int32{
	"ALL_METRICS":            0,
	"REQUEST_COUNT":          1,
	"REQUEST_DURATION":       2,
	"REQUEST_SIZE":           3,
	"RESPONSE_SIZE":          4,
	"TCP_OPEN_CONNECTIONS":   5,
	"TCP_CLOSED_CONNECTIONS": 6,
	"TCP_SENT_BYTES":         7,
	"TCP_RECEIVED_BYTES":     8,
	"GRPC_REQUEST_MESSAGES":  9,
	"GRPC_RESPONSE_MESSAGES": 10,
}

func (x MetricsOverrides_StandardMetric) String() string {
	return proto.EnumName(MetricsOverrides_StandardMetric_name, int32(x))
}

func (MetricsOverrides_StandardMetric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4, 0}
}

type MetricsOverrides_TrafficMatch int32

const (
	MetricsOverrides_ALL_TRAFFIC      MetricsOverrides_TrafficMatch = 0
	MetricsOverrides_INBOUND_TRAFFIC  MetricsOverrides_TrafficMatch = 1
	MetricsOverrides_OUTBOUND_TRAFFIC MetricsOverrides_TrafficMatch = 2
)

var MetricsOverrides_TrafficMatch_name = map[int32]string{
	0: "ALL_TRAFFIC",
	1: "INBOUND_TRAFFIC",
	2: "OUTBOUND_TRAFFIC",
}

var MetricsOverrides_TrafficMatch_value = map[string]int32{
	"ALL_TRAFFIC":      0,
	"INBOUND_TRAFFIC":  1,
	"OUTBOUND_TRAFFIC": 2,
}

func (x MetricsOverrides_TrafficMatch) String() string {
	return proto.EnumName(MetricsOverrides_TrafficMatch_name, int32(x))
}

func (MetricsOverrides_TrafficMatch) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4, 1}
}

type MetricsOverrides_TagOverride_Operation int32

const (
	MetricsOverrides_TagOverride_INSERT_OR_UPDATE MetricsOverrides_TagOverride_Operation = 0
	MetricsOverrides_TagOverride_REMOVE           MetricsOverrides_TagOverride_Operation = 1
)

var MetricsOverrides_TagOverride_Operation_name = map[int32]string{
	0: "INSERT_OR_UPDATE",
	1: "REMOVE",
}

var MetricsOverrides_TagOverride_Operation_value = map[string]int32{
	"INSERT_OR_UPDATE": 0,
	"REMOVE":           1,
}

func (x MetricsOverrides_TagOverride_Operation) String() string {
	return proto.EnumName(MetricsOverrides_TagOverride_Operation_name, int32(x))
}

func (MetricsOverrides_TagOverride_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4, 0, 0}
}

// Telemetry defines how the telemetry is generated for workloads within a mesh.
//
// For mesh level configuration, put the resource in root configuration namespace for
// your Istio installation *without* a workload selector.
//
// For any namespace, including the root configuration namespace, it is only valid
// to have a single workload selector-less Telemetry resource.
//
// For resources with a workload selector, it is only valid to have one resource selecting
// any given workload.
//
// Telemetry configuration will use a "shallow merge" semantic for configuration override
// for each telemetry type (Tracing, Metrics, AccessLogging). For example, Tracing configuration
// will support overrides of the fields `providers`, `random_sampling_percentage`, `disable_span_reporting`,
// and `custom_tags` at each level in the configuration hierarchy, with missing values filled in
// from parent resources. However, when specified, fields like `custom_tags` will
// fully replace any values provided by parent configuration.
//
// The hierarchy of Telemetry configuration is as follows:
// 1. Workload-specific configuration
// 1. Namespace-specific configuration
// 1. Root namespace configuration
//
// Examples:
//
// Policy to enable random sampling for 10% of traffic:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   tracing:
//   - randomSamplingPercentage: 10.00
// ```
//
// Policy to disable trace reporting for the "foo" workload (note: tracing
// context will still be propagated):
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing
//   namespace: bar
// spec:
//   selector:
//     labels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - disableSpanReporting: true
// ```
//
// Policy to select the alternate zipkin provider for trace reporting:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing-alternate
//   namespace: baz
// spec:
//   selector:
//     labels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - providers:
//     - name: "zipkin-alternate"
//     randomSamplingPercentage: 10.00
// ```
//
// Policy to add a custom tag from a literal value:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   tracing:
//   - randomSamplingPercentage: 10.00
//     customTags:
//       my_new_foo_tag:
//         literal:
//           value: "foo"
// ```
//
// Policy to disable server-side metrics for Stackdriver for an entire mesh:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   metrics:
//   - providers:
//     - name: stackdriver
//     overrides:
//     - metrics: [ ALL_METRICS ]
//       trafficMatch: INBOUND_TRAFFIC
//       disabled: true
// ```
//
// Policy to add dimensions to all Prometheus metrics for a namespace:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: namespace-metrics
//   namespace: foo
// spec:
//   # no selector specified, applies to all workloads
//   metrics:
//   - providers:
//     - name: prometheus
//     overrides:
//     - metrics: [ ALL_METRICS ]
//       trafficMatch: ALL_TRAFFIC
//       tagOverrides:
//         destination_port:
//           operation: INSERT_OR_UPDATE
//           expression: "string(destination.port)"
//         request_host:
//           operation: INSERT_OR_UPDATE
//           expression: "request.host"
// ```
//
// Policy to remove the source_workload dimension on some Prometheus metrics for a workload:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: remove-source-workload
//   namespace: foo
// spec:
//   selector:
//     labels:
//       service.istio.io/canonical-name: bar
//   metrics:
//   - providers:
//     - name: prometheus
//     overrides:
//     - metrics: [ REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE ]
//       trafficMatch: ALL_TRAFFIC
//       tagOverrides:
//         source_workload:
//           operation: REMOVE
// ```
//
// Policy to enable access logging for the entire mesh:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   accessLogging:
//   - providers:
//     - name: envoyFileAccessLogger
// ```
//
// Policy to disable access logging for a namespace:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: namespace-no-log
//   namespace: foo
// spec:
//   # no selector specified, applies to all workloads
//   accessLogging:
//   - disabled: true
// ```
//
// <!-- crd generation tags
// +cue-gen:Telemetry:groupName:telemetry.istio.io
// +cue-gen:Telemetry:version:v1alpha1
// +cue-gen:Telemetry:storageVersion
// +cue-gen:Telemetry:annotations:helm.sh/resource-policy=keep
// +cue-gen:Telemetry:labels:app=istio-pilot,chart=istio,istio=telemetry,heritage=Tiller,release=istio
// +cue-gen:Telemetry:subresource:status
// +cue-gen:Telemetry:scope:Namespaced
// +cue-gen:Telemetry:resource:categories=istio-io,telemetry-istio-io,shortNames=telemetry,plural=telemetries
// +cue-gen:Telemetry:preserveUnknownFields:false
// +cue-gen:Telemetry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
// representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
// Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=telemetry.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Telemetry struct {
	// Optional. The selector decides where to apply the Telemetry policy.
	// If not set, the Telemetry policy will be applied to all workloads in the
	// same namespace as the Telemetry policy.
	Selector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Optional. Tracing configures the tracing behavior for all
	// selected workloads.
	Tracing []*Tracing `protobuf:"bytes,2,rep,name=tracing,proto3" json:"tracing,omitempty"`
	// Optional. Metrics configure the metrics behavior for all
	// selected workloads.
	Metrics []*Metrics `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics,omitempty"`
	// Optional. AccessLogging configures the access logging behavior for all
	// selected workloads.
	AccessLogging        []*AccessLogging `protobuf:"bytes,4,rep,name=access_logging,json=accessLogging,proto3" json:"access_logging,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Telemetry) Reset()         { *m = Telemetry{} }
func (m *Telemetry) String() string { return proto.CompactTextString(m) }
func (*Telemetry) ProtoMessage()    {}
func (*Telemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{0}
}
func (m *Telemetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Telemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Telemetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Telemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Telemetry.Merge(m, src)
}
func (m *Telemetry) XXX_Size() int {
	return m.Size()
}
func (m *Telemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_Telemetry.DiscardUnknown(m)
}

var xxx_messageInfo_Telemetry proto.InternalMessageInfo

func (m *Telemetry) GetSelector() *v1beta1.WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *Telemetry) GetTracing() []*Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *Telemetry) GetMetrics() []*Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Telemetry) GetAccessLogging() []*AccessLogging {
	if m != nil {
		return m.AccessLogging
	}
	return nil
}

// Tracing configures tracing behavior for workloads within a mesh.
// It can be used to enable/disable tracing, as well as to set sampling
// rates and custom tag extraction.
type Tracing struct {
	// Optional. Name of provider(s) to use for span reporting. If a provider is
	// not specified, the [default tracing provider][istio.mesh.v1alpha1.MeshConfig.default_providers.tracing]
	// will be used.
	// NOTE: At the moment, only a single provider can be specified in a given
	// Tracing rule.
	Providers []*ProviderRef `protobuf:"bytes,2,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls the rate at which traffic will be selected for tracing if no
	// prior sampling decision has been made. If a prior sampling decision has been
	// made, that decision will be respected. However, if no sampling decision
	// has been made (example: no `x-b3-sampled` tracing header was present in the
	// requests), the traffic will be selected for telemetry generation at the
	// percentage specified.
	//
	// Defaults to 0%. Valid values [0.00-100.00]. Can be specified in 0.01%
	// increments.
	RandomSamplingPercentage *types.DoubleValue `protobuf:"bytes,3,opt,name=random_sampling_percentage,json=randomSamplingPercentage,proto3" json:"random_sampling_percentage,omitempty"`
	// Controls span reporting. If set to true, no spans will be reported for
	// impacted workloads. This does NOT impact context propagation or trace
	// sampling behavior.
	DisableSpanReporting *types.BoolValue `protobuf:"bytes,4,opt,name=disable_span_reporting,json=disableSpanReporting,proto3" json:"disable_span_reporting,omitempty"`
	// Optional. Configures additional custom tags to the generated trace spans.
	CustomTags           map[string]*Tracing_CustomTag `protobuf:"bytes,5,rep,name=custom_tags,json=customTags,proto3" json:"custom_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Tracing) Reset()         { *m = Tracing{} }
func (m *Tracing) String() string { return proto.CompactTextString(m) }
func (*Tracing) ProtoMessage()    {}
func (*Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1}
}
func (m *Tracing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing.Merge(m, src)
}
func (m *Tracing) XXX_Size() int {
	return m.Size()
}
func (m *Tracing) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing proto.InternalMessageInfo

func (m *Tracing) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Tracing) GetRandomSamplingPercentage() *types.DoubleValue {
	if m != nil {
		return m.RandomSamplingPercentage
	}
	return nil
}

func (m *Tracing) GetDisableSpanReporting() *types.BoolValue {
	if m != nil {
		return m.DisableSpanReporting
	}
	return nil
}

func (m *Tracing) GetCustomTags() map[string]*Tracing_CustomTag {
	if m != nil {
		return m.CustomTags
	}
	return nil
}

// CustomTag defines a tag to be added to a trace span that is based on
// an operator-supplied value. This value can either be a hard-coded value,
// a value taken from an environment variable known to the sidecar proxy, or
// from a request header.
type Tracing_CustomTag struct {
	// Types that are valid to be assigned to Type:
	//	*Tracing_CustomTag_Literal
	//	*Tracing_CustomTag_Environment
	//	*Tracing_CustomTag_Header
	Type                 isTracing_CustomTag_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Tracing_CustomTag) Reset()         { *m = Tracing_CustomTag{} }
func (m *Tracing_CustomTag) String() string { return proto.CompactTextString(m) }
func (*Tracing_CustomTag) ProtoMessage()    {}
func (*Tracing_CustomTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 0}
}
func (m *Tracing_CustomTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_CustomTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_CustomTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_CustomTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_CustomTag.Merge(m, src)
}
func (m *Tracing_CustomTag) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_CustomTag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_CustomTag.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_CustomTag proto.InternalMessageInfo

type isTracing_CustomTag_Type interface {
	isTracing_CustomTag_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Tracing_CustomTag_Literal struct {
	Literal *Tracing_Literal `protobuf:"bytes,1,opt,name=literal,proto3,oneof" json:"literal,omitempty"`
}
type Tracing_CustomTag_Environment struct {
	Environment *Tracing_Environment `protobuf:"bytes,2,opt,name=environment,proto3,oneof" json:"environment,omitempty"`
}
type Tracing_CustomTag_Header struct {
	Header *Tracing_RequestHeader `protobuf:"bytes,3,opt,name=header,proto3,oneof" json:"header,omitempty"`
}

func (*Tracing_CustomTag_Literal) isTracing_CustomTag_Type()     {}
func (*Tracing_CustomTag_Environment) isTracing_CustomTag_Type() {}
func (*Tracing_CustomTag_Header) isTracing_CustomTag_Type()      {}

func (m *Tracing_CustomTag) GetType() isTracing_CustomTag_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Tracing_CustomTag) GetLiteral() *Tracing_Literal {
	if x, ok := m.GetType().(*Tracing_CustomTag_Literal); ok {
		return x.Literal
	}
	return nil
}

func (m *Tracing_CustomTag) GetEnvironment() *Tracing_Environment {
	if x, ok := m.GetType().(*Tracing_CustomTag_Environment); ok {
		return x.Environment
	}
	return nil
}

func (m *Tracing_CustomTag) GetHeader() *Tracing_RequestHeader {
	if x, ok := m.GetType().(*Tracing_CustomTag_Header); ok {
		return x.Header
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Tracing_CustomTag) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Tracing_CustomTag_Literal)(nil),
		(*Tracing_CustomTag_Environment)(nil),
		(*Tracing_CustomTag_Header)(nil),
	}
}

type Tracing_Literal struct {
	// The tag value to use.
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Literal) Reset()         { *m = Tracing_Literal{} }
func (m *Tracing_Literal) String() string { return proto.CompactTextString(m) }
func (*Tracing_Literal) ProtoMessage()    {}
func (*Tracing_Literal) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 1}
}
func (m *Tracing_Literal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Literal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Literal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Literal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Literal.Merge(m, src)
}
func (m *Tracing_Literal) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Literal) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Literal.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Literal proto.InternalMessageInfo

func (m *Tracing_Literal) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Tracing_Environment struct {
	// Name of the environment variable from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the environment variable is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Environment) Reset()         { *m = Tracing_Environment{} }
func (m *Tracing_Environment) String() string { return proto.CompactTextString(m) }
func (*Tracing_Environment) ProtoMessage()    {}
func (*Tracing_Environment) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 2}
}
func (m *Tracing_Environment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Environment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Environment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Environment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Environment.Merge(m, src)
}
func (m *Tracing_Environment) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Environment) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Environment.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Environment proto.InternalMessageInfo

func (m *Tracing_Environment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_Environment) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

type Tracing_RequestHeader struct {
	// Name of the header from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the header is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_RequestHeader) Reset()         { *m = Tracing_RequestHeader{} }
func (m *Tracing_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*Tracing_RequestHeader) ProtoMessage()    {}
func (*Tracing_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 3}
}
func (m *Tracing_RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_RequestHeader.Merge(m, src)
}
func (m *Tracing_RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_RequestHeader proto.InternalMessageInfo

func (m *Tracing_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_RequestHeader) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

// Used to bind Telemetry configuration to specific providers for
// targeted customization.
type ProviderRef struct {
	// Required. Name of Telemetry provider in MeshConfig.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProviderRef) Reset()         { *m = ProviderRef{} }
func (m *ProviderRef) String() string { return proto.CompactTextString(m) }
func (*ProviderRef) ProtoMessage()    {}
func (*ProviderRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{2}
}
func (m *ProviderRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderRef.Merge(m, src)
}
func (m *ProviderRef) XXX_Size() int {
	return m.Size()
}
func (m *ProviderRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderRef.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderRef proto.InternalMessageInfo

func (m *ProviderRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Metrics defines the workload-level overrides for metrics generation behavior
// within a mesh. It can be used to enable/disable metrics generation, as well
// as to customize the dimensions of the generated metrics.
type Metrics struct {
	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default metrics provider][istio.mesh.v1alpha1.MeshConfig.default_providers.metrics]
	// will be used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Optional. Set of overrides to apply. These include customization of dimensions
	// as well as enablement control.
	Overrides            []*MetricsOverrides `protobuf:"bytes,2,rep,name=overrides,proto3" json:"overrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{3}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Metrics) GetOverrides() []*MetricsOverrides {
	if m != nil {
		return m.Overrides
	}
	return nil
}

// MetricsOverrides defines custom metric generation behavior for an individual
// metric or the set of all standard metrics.
type MetricsOverrides struct {
	// Optional. If not specified, config applied to all metrics.
	Metrics []MetricsOverrides_StandardMetric `protobuf:"varint,1,rep,packed,name=metrics,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_StandardMetric" json:"metrics,omitempty"`
	// Optional. Matches traffic direction *from the perspective of the
	// workload*.
	TrafficMatch MetricsOverrides_TrafficMatch `protobuf:"varint,2,opt,name=traffic_match,json=trafficMatch,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_TrafficMatch" json:"traffic_match,omitempty"`
	// Optional. Must explicitly set this to "true" to turn off metrics reporting
	// for the listed metrics.
	Disabled *types.BoolValue `protobuf:"bytes,3,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Optional. Collection of tag names and tag expressions to override in the
	// selected metric(s).
	// The key in the map is the name of the tag.
	// The value in the map is the operation to perform on the the tag.
	// WARNING: some providers may not support adding/removing tags.
	TagOverrides         map[string]*MetricsOverrides_TagOverride `protobuf:"bytes,4,rep,name=tag_overrides,json=tagOverrides,proto3" json:"tag_overrides,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *MetricsOverrides) Reset()         { *m = MetricsOverrides{} }
func (m *MetricsOverrides) String() string { return proto.CompactTextString(m) }
func (*MetricsOverrides) ProtoMessage()    {}
func (*MetricsOverrides) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4}
}
func (m *MetricsOverrides) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsOverrides) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsOverrides.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsOverrides) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsOverrides.Merge(m, src)
}
func (m *MetricsOverrides) XXX_Size() int {
	return m.Size()
}
func (m *MetricsOverrides) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsOverrides.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsOverrides proto.InternalMessageInfo

func (m *MetricsOverrides) GetMetrics() []MetricsOverrides_StandardMetric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *MetricsOverrides) GetTrafficMatch() MetricsOverrides_TrafficMatch {
	if m != nil {
		return m.TrafficMatch
	}
	return MetricsOverrides_ALL_TRAFFIC
}

func (m *MetricsOverrides) GetDisabled() *types.BoolValue {
	if m != nil {
		return m.Disabled
	}
	return nil
}

func (m *MetricsOverrides) GetTagOverrides() map[string]*MetricsOverrides_TagOverride {
	if m != nil {
		return m.TagOverrides
	}
	return nil
}

type MetricsOverrides_TagOverride struct {
	Operation MetricsOverrides_TagOverride_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_TagOverride_Operation" json:"operation,omitempty"`
	// Expression is only considered if the operation is INSERT_OR_UPDATE.
	// Expressions are [CEL expressions](https://opensource.google/projects/cel) over attributes.
	// Examples include: "string(destination.port)" and "request.host".
	// Istio exposes all standard [Envoy attributes](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes).
	// Additionally, Istio exposes node metadata as attributes.
	// More information is provided in the [customization docs](https://istio.io/latest/docs/tasks/observability/metrics/customize-metrics/#use-expressions-for-values).
	Expression           string   `protobuf:"bytes,2,opt,name=expression,proto3" json:"expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricsOverrides_TagOverride) Reset()         { *m = MetricsOverrides_TagOverride{} }
func (m *MetricsOverrides_TagOverride) String() string { return proto.CompactTextString(m) }
func (*MetricsOverrides_TagOverride) ProtoMessage()    {}
func (*MetricsOverrides_TagOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4, 0}
}
func (m *MetricsOverrides_TagOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsOverrides_TagOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsOverrides_TagOverride.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsOverrides_TagOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsOverrides_TagOverride.Merge(m, src)
}
func (m *MetricsOverrides_TagOverride) XXX_Size() int {
	return m.Size()
}
func (m *MetricsOverrides_TagOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsOverrides_TagOverride.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsOverrides_TagOverride proto.InternalMessageInfo

func (m *MetricsOverrides_TagOverride) GetOperation() MetricsOverrides_TagOverride_Operation {
	if m != nil {
		return m.Operation
	}
	return MetricsOverrides_TagOverride_INSERT_OR_UPDATE
}

func (m *MetricsOverrides_TagOverride) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

// Access logging defines the workload-level overrides for access log generation.
// It can be used to select provider or enable/disable access log generation for a workload.
type AccessLogging struct {
	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default logging provider][istio.mesh.v1alpha1.MeshConfig.default_providers.]
	// will be used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls logging. If set to true, no access logs will be generated for
	// impacted workloads (for the specified providers).
	Disabled             *types.BoolValue `protobuf:"bytes,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AccessLogging) Reset()         { *m = AccessLogging{} }
func (m *AccessLogging) String() string { return proto.CompactTextString(m) }
func (*AccessLogging) ProtoMessage()    {}
func (*AccessLogging) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{5}
}
func (m *AccessLogging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessLogging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessLogging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessLogging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessLogging.Merge(m, src)
}
func (m *AccessLogging) XXX_Size() int {
	return m.Size()
}
func (m *AccessLogging) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessLogging.DiscardUnknown(m)
}

var xxx_messageInfo_AccessLogging proto.InternalMessageInfo

func (m *AccessLogging) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *AccessLogging) GetDisabled() *types.BoolValue {
	if m != nil {
		return m.Disabled
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricsOverrides_StandardMetric", MetricsOverrides_StandardMetric_name, MetricsOverrides_StandardMetric_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricsOverrides_TrafficMatch", MetricsOverrides_TrafficMatch_name, MetricsOverrides_TrafficMatch_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricsOverrides_TagOverride_Operation", MetricsOverrides_TagOverride_Operation_name, MetricsOverrides_TagOverride_Operation_value)
	proto.RegisterType((*Telemetry)(nil), "istio.telemetry.v1alpha1.Telemetry")
	proto.RegisterType((*Tracing)(nil), "istio.telemetry.v1alpha1.Tracing")
	proto.RegisterMapType((map[string]*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTagsEntry")
	proto.RegisterType((*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTag")
	proto.RegisterType((*Tracing_Literal)(nil), "istio.telemetry.v1alpha1.Tracing.Literal")
	proto.RegisterType((*Tracing_Environment)(nil), "istio.telemetry.v1alpha1.Tracing.Environment")
	proto.RegisterType((*Tracing_RequestHeader)(nil), "istio.telemetry.v1alpha1.Tracing.RequestHeader")
	proto.RegisterType((*ProviderRef)(nil), "istio.telemetry.v1alpha1.ProviderRef")
	proto.RegisterType((*Metrics)(nil), "istio.telemetry.v1alpha1.Metrics")
	proto.RegisterType((*MetricsOverrides)(nil), "istio.telemetry.v1alpha1.MetricsOverrides")
	proto.RegisterMapType((map[string]*MetricsOverrides_TagOverride)(nil), "istio.telemetry.v1alpha1.MetricsOverrides.TagOverridesEntry")
	proto.RegisterType((*MetricsOverrides_TagOverride)(nil), "istio.telemetry.v1alpha1.MetricsOverrides.TagOverride")
	proto.RegisterType((*AccessLogging)(nil), "istio.telemetry.v1alpha1.AccessLogging")
}

func init() {
	proto.RegisterFile("telemetry/v1alpha1/telemetry.proto", fileDescriptor_991c84745e2b7651)
}

var fileDescriptor_991c84745e2b7651 = []byte{
	// 1063 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x72, 0xe3, 0xc4,
	0x13, 0xb6, 0x9c, 0xac, 0xbd, 0x6e, 0xc7, 0x8e, 0x76, 0x7e, 0xf9, 0xa5, 0x8c, 0xa1, 0xb2, 0xbb,
	0x06, 0x8a, 0x05, 0x2a, 0x72, 0x25, 0x54, 0x2d, 0x7f, 0x0f, 0xeb, 0xd8, 0x93, 0xb5, 0x29, 0x47,
	0xf2, 0x8e, 0xe4, 0x50, 0xa4, 0x28, 0x54, 0x13, 0x7b, 0xa2, 0x88, 0x95, 0x25, 0x31, 0x1a, 0x7b,
	0xc9, 0x1b, 0x70, 0xe0, 0x0e, 0x0f, 0xc3, 0x03, 0x70, 0xe4, 0x11, 0xa8, 0x1c, 0xb9, 0x70, 0xe5,
	0x48, 0xe9, 0x9f, 0x2d, 0x6f, 0x36, 0x78, 0x93, 0xe2, 0xa6, 0xf9, 0xba, 0xbf, 0x6f, 0xba, 0x7b,
	0xba, 0xbb, 0x04, 0x0d, 0xc1, 0x1c, 0x36, 0x61, 0x82, 0x5f, 0x34, 0x67, 0x7b, 0xd4, 0xf1, 0xcf,
	0xe9, 0x5e, 0x73, 0x0e, 0x29, 0x3e, 0xf7, 0x84, 0x87, 0x6a, 0x76, 0x20, 0x6c, 0x4f, 0x59, 0xc0,
	0xa9, 0x67, 0xfd, 0x4d, 0x71, 0xe1, 0xb3, 0xe6, 0x6c, 0xef, 0x94, 0x09, 0xba, 0xd7, 0x0c, 0x98,
	0xc3, 0x46, 0xc2, 0xe3, 0x31, 0xad, 0xbe, 0x63, 0x79, 0x9e, 0xe5, 0xb0, 0x66, 0x74, 0x3a, 0x9d,
	0x9e, 0x35, 0x5f, 0x70, 0xea, 0xfb, 0x8c, 0x07, 0xb1, 0xbd, 0xf1, 0x73, 0x1e, 0x4a, 0x46, 0xaa,
	0x89, 0x9e, 0xc0, 0xdd, 0x94, 0x5f, 0x93, 0x1e, 0x48, 0x8f, 0xca, 0xfb, 0xef, 0x28, 0xc9, 0xbd,
	0x17, 0x3e, 0x53, 0x92, 0x3b, 0x94, 0xaf, 0x3c, 0xfe, 0xdc, 0xf1, 0xe8, 0x58, 0x4f, 0x7c, 0xc9,
	0x9c, 0x85, 0x3e, 0x87, 0xa2, 0xe0, 0x74, 0x64, 0xbb, 0x56, 0x2d, 0xff, 0x60, 0xed, 0x51, 0x79,
	0xff, 0xa1, 0x72, 0x5d, 0xe0, 0x8a, 0x11, 0x3b, 0x92, 0x94, 0x11, 0x92, 0x43, 0x17, 0x7b, 0x14,
	0xd4, 0xd6, 0x56, 0x91, 0x8f, 0x62, 0x47, 0x92, 0x32, 0x90, 0x0a, 0x55, 0x3a, 0x1a, 0xb1, 0x20,
	0x30, 0x1d, 0xcf, 0xb2, 0xc2, 0x00, 0xd6, 0x23, 0x8d, 0xf7, 0xae, 0xd7, 0x68, 0x45, 0xfe, 0xfd,
	0xd8, 0x9d, 0x54, 0x68, 0xf6, 0xd8, 0xf8, 0xb3, 0x00, 0xc5, 0x24, 0x42, 0xd4, 0x86, 0x92, 0xcf,
	0xbd, 0x99, 0x3d, 0x66, 0x3c, 0x48, 0xf2, 0x7a, 0xf7, 0x7a, 0xd9, 0x41, 0xe2, 0x4a, 0xd8, 0x19,
	0x59, 0xf0, 0xd0, 0x09, 0xd4, 0x39, 0x75, 0xc7, 0xde, 0xc4, 0x0c, 0xe8, 0xc4, 0x77, 0x6c, 0xd7,
	0x32, 0x7d, 0xc6, 0x47, 0xcc, 0x15, 0xd4, 0x62, 0xb5, 0xb5, 0xa8, 0xdc, 0x6f, 0x29, 0xf1, 0x7b,
	0x29, 0xe9, 0x7b, 0x29, 0x1d, 0x6f, 0x7a, 0xea, 0xb0, 0x63, 0xea, 0x4c, 0x19, 0xa9, 0xc5, 0x7c,
	0x3d, 0xa1, 0x0f, 0xe6, 0x6c, 0x34, 0x80, 0xed, 0xb1, 0x1d, 0xd0, 0x53, 0x87, 0x99, 0x81, 0x4f,
	0x5d, 0x93, 0x33, 0xdf, 0xe3, 0x22, 0x2e, 0x42, 0xa8, 0x5b, 0xbf, 0xa2, 0x7b, 0xe0, 0x79, 0x4e,
	0xac, 0xba, 0x95, 0x30, 0x75, 0x9f, 0xba, 0x24, 0xe5, 0x21, 0x02, 0xe5, 0xd1, 0x34, 0x10, 0xde,
	0xc4, 0x14, 0xd4, 0x0a, 0x6a, 0x77, 0xa2, 0xa4, 0xf7, 0x56, 0x3e, 0xa6, 0xd2, 0x8e, 0x48, 0x06,
	0xb5, 0x02, 0xec, 0x0a, 0x7e, 0x41, 0x60, 0x34, 0x07, 0xea, 0x7f, 0x4b, 0x50, 0x9a, 0xdb, 0x11,
	0x86, 0xa2, 0x63, 0x0b, 0xc6, 0xa9, 0x93, 0xf4, 0xda, 0xfb, 0xab, 0xd5, 0xfb, 0x31, 0xa1, 0x9b,
	0x23, 0x29, 0x17, 0x3d, 0x83, 0x32, 0x73, 0x67, 0x36, 0xf7, 0xdc, 0x09, 0x73, 0x45, 0x2d, 0x1f,
	0x49, 0xed, 0xae, 0x96, 0xc2, 0x0b, 0x52, 0x37, 0x47, 0xb2, 0x1a, 0xa8, 0x07, 0x85, 0x73, 0x46,
	0xc7, 0x8c, 0x27, 0xaf, 0xd2, 0x5c, 0xad, 0x46, 0xd8, 0xf7, 0x53, 0x16, 0x88, 0x6e, 0x44, 0xeb,
	0xe6, 0x48, 0x22, 0x70, 0x50, 0x80, 0xf5, 0x70, 0x74, 0xea, 0xf7, 0xa1, 0x98, 0xc4, 0x8e, 0xb6,
	0xe0, 0xce, 0x2c, 0x2c, 0x7c, 0x94, 0x75, 0x89, 0xc4, 0x87, 0xfa, 0x21, 0x94, 0x33, 0x11, 0x21,
	0x04, 0xeb, 0x2e, 0x9d, 0xa4, 0x3e, 0xd1, 0x37, 0x7a, 0x1b, 0x2a, 0x63, 0x76, 0x46, 0xa7, 0x8e,
	0x30, 0x63, 0x81, 0x7c, 0x64, 0xdc, 0x48, 0xc0, 0xe8, 0x35, 0xeb, 0x5d, 0xa8, 0x2c, 0xc5, 0x72,
	0x7b, 0xa5, 0xef, 0x60, 0xf3, 0xa5, 0xc7, 0x44, 0x32, 0xac, 0x3d, 0x67, 0x17, 0x89, 0x54, 0xf8,
	0x89, 0x5a, 0x69, 0x32, 0x71, 0xdd, 0x3f, 0xbc, 0x41, 0x83, 0x24, 0x99, 0x7f, 0x96, 0xff, 0x44,
	0x6a, 0x3c, 0x84, 0x72, 0x66, 0x6a, 0x5e, 0x15, 0x73, 0xe3, 0x17, 0x09, 0x8a, 0xc9, 0xd0, 0x2f,
	0xcf, 0xa3, 0x74, 0xcb, 0x79, 0xec, 0x42, 0xc9, 0x9b, 0x31, 0xce, 0xed, 0x31, 0x4b, 0x87, 0xfa,
	0x83, 0x95, 0xfb, 0x46, 0x4b, 0x19, 0x64, 0x41, 0x6e, 0xfc, 0x55, 0x04, 0xf9, 0x65, 0x3b, 0xd2,
	0x17, 0xcb, 0x2c, 0x8c, 0xb0, 0xba, 0xff, 0xe9, 0xeb, 0x8b, 0x2b, 0xba, 0xa0, 0xee, 0x98, 0xf2,
	0x71, 0x6c, 0x58, 0x2c, 0xb9, 0x6f, 0xa0, 0x22, 0x38, 0x3d, 0x3b, 0xb3, 0x47, 0xe6, 0x84, 0x8a,
	0xd1, 0x79, 0x54, 0xf6, 0xea, 0xfe, 0xc7, 0x37, 0x90, 0x36, 0x62, 0xfe, 0x51, 0x48, 0x27, 0x1b,
	0x22, 0x73, 0x42, 0x8f, 0xe1, 0x6e, 0xb2, 0x0b, 0xc6, 0x49, 0xe7, 0xff, 0xdb, 0xde, 0x98, 0xfb,
	0x22, 0x0a, 0x15, 0x41, 0x2d, 0x73, 0x51, 0xcd, 0x78, 0xf3, 0x7e, 0x71, 0x93, 0xa8, 0xa8, 0x35,
	0x3f, 0xc4, 0x8b, 0x63, 0x43, 0x64, 0xa0, 0xfa, 0xaf, 0x12, 0x94, 0x33, 0x3e, 0xe8, 0x5b, 0x28,
	0x79, 0x3e, 0xe3, 0x54, 0xd8, 0x9e, 0x1b, 0xb5, 0x49, 0x75, 0xff, 0xc9, 0xed, 0xae, 0x53, 0xb4,
	0x54, 0x87, 0x2c, 0x24, 0xd1, 0x0e, 0x00, 0xfb, 0xc1, 0xe7, 0x2c, 0x08, 0xc2, 0x0b, 0xe2, 0xf1,
	0xc8, 0x20, 0x8d, 0x5d, 0x28, 0xcd, 0x79, 0x68, 0x0b, 0xe4, 0x9e, 0xaa, 0x63, 0x62, 0x98, 0x1a,
	0x31, 0x87, 0x83, 0x4e, 0xcb, 0xc0, 0x72, 0x0e, 0x01, 0x14, 0x08, 0x3e, 0xd2, 0x8e, 0xb1, 0x2c,
	0xd5, 0x5f, 0xc0, 0xbd, 0x2b, 0x19, 0xbe, 0x62, 0x9a, 0xfa, 0xcb, 0xd3, 0xf4, 0xf8, 0x76, 0x19,
	0x65, 0x07, 0xeb, 0xc7, 0x3c, 0x54, 0x97, 0x9b, 0x09, 0x6d, 0x42, 0xb9, 0xd5, 0xef, 0x9b, 0x47,
	0xd8, 0x20, 0xbd, 0xb6, 0x2e, 0xe7, 0xd0, 0x3d, 0xa8, 0x10, 0xfc, 0x6c, 0x88, 0x75, 0xc3, 0x6c,
	0x6b, 0x43, 0xd5, 0x90, 0xa5, 0x30, 0xa3, 0x14, 0xea, 0x0c, 0x49, 0xcb, 0xe8, 0x69, 0xaa, 0x9c,
	0x47, 0x32, 0x6c, 0xa4, 0xa8, 0xde, 0x3b, 0xc1, 0xf2, 0x5a, 0x4c, 0xd5, 0x07, 0x9a, 0xaa, 0xe3,
	0x18, 0x5a, 0x47, 0x35, 0xd8, 0x32, 0xda, 0x03, 0x53, 0x1b, 0x60, 0xd5, 0x6c, 0x6b, 0xaa, 0x8a,
	0xdb, 0x21, 0x5b, 0x97, 0xef, 0xa0, 0x3a, 0x6c, 0x87, 0x96, 0x76, 0x5f, 0xd3, 0x71, 0x67, 0xc9,
	0x56, 0x40, 0x08, 0xaa, 0xa1, 0x4d, 0xc7, 0xaa, 0x61, 0x1e, 0x7c, 0x6d, 0x60, 0x5d, 0x2e, 0xa2,
	0x6d, 0x40, 0x21, 0x46, 0x70, 0x1b, 0xf7, 0x8e, 0x71, 0x27, 0xc1, 0xef, 0xa2, 0x37, 0xe0, 0xff,
	0x4f, 0xc9, 0xa0, 0x6d, 0xa6, 0xb1, 0x1c, 0x61, 0x5d, 0x6f, 0x3d, 0xc5, 0xba, 0x5c, 0x0a, 0xaf,
	0x48, 0x4c, 0x49, 0x50, 0x73, 0x1b, 0x34, 0xbe, 0x84, 0x8d, 0x6c, 0xef, 0xa7, 0x75, 0x30, 0x48,
	0xeb, 0xf0, 0xb0, 0xd7, 0x96, 0x73, 0xe8, 0x7f, 0xb0, 0xd9, 0x53, 0x0f, 0xb4, 0xa1, 0xda, 0x99,
	0x83, 0x51, 0x25, 0xb4, 0xa1, 0xb1, 0x8c, 0xe6, 0x1b, 0x3f, 0x49, 0x50, 0x59, 0xfa, 0x7b, 0xf8,
	0x6f, 0x56, 0x52, 0x76, 0x00, 0xf3, 0xaf, 0x3f, 0x80, 0x07, 0xbb, 0xbf, 0x5d, 0xee, 0x48, 0xbf,
	0x5f, 0xee, 0x48, 0x7f, 0x5c, 0xee, 0x48, 0x27, 0xf7, 0xe3, 0x6b, 0x6d, 0xaf, 0x49, 0x7d, 0xbb,
	0x79, 0xf5, 0xdf, 0xf2, 0xb4, 0x10, 0x89, 0x7d, 0xf4, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf6,
	0xbf, 0xf8, 0xdc, 0x78, 0x0a, 0x00, 0x00,
}

func (m *Telemetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Telemetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Telemetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccessLogging) > 0 {
		for iNdEx := len(m.AccessLogging) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccessLogging[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tracing) > 0 {
		for iNdEx := len(m.Tracing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tracing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomTags) > 0 {
		for k := range m.CustomTags {
			v := m.CustomTags[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTelemetry(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DisableSpanReporting != nil {
		{
			size, err := m.DisableSpanReporting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RandomSamplingPercentage != nil {
		{
			size, err := m.RandomSamplingPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_CustomTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Literal != nil {
		{
			size, err := m.Literal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Environment != nil {
		{
			size, err := m.Environment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_Literal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_Environment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Overrides) > 0 {
		for iNdEx := len(m.Overrides) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Overrides[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricsOverrides) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsOverrides) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsOverrides) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TagOverrides) > 0 {
		for k := range m.TagOverrides {
			v := m.TagOverrides[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTelemetry(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TrafficMatch != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TrafficMatch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Metrics) > 0 {
		dAtA11 := make([]byte, len(m.Metrics)*10)
		var j10 int
		for _, num := range m.Metrics {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTelemetry(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsOverrides_TagOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsOverrides_TagOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsOverrides_TagOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Expression) > 0 {
		i -= len(m.Expression)
		copy(dAtA[i:], m.Expression)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Expression)))
		i--
		dAtA[i] = 0x12
	}
	if m.Operation != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessLogging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessLogging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Telemetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Tracing) > 0 {
		for _, e := range m.Tracing {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.AccessLogging) > 0 {
		for _, e := range m.AccessLogging {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.RandomSamplingPercentage != nil {
		l = m.RandomSamplingPercentage.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DisableSpanReporting != nil {
		l = m.DisableSpanReporting.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.CustomTags) > 0 {
		for k, v := range m.CustomTags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTelemetry(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Literal != nil {
		l = m.Literal.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Overrides) > 0 {
		for _, e := range m.Overrides {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricsOverrides) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		l = 0
		for _, e := range m.Metrics {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if m.TrafficMatch != 0 {
		n += 1 + sovTelemetry(uint64(m.TrafficMatch))
	}
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.TagOverrides) > 0 {
		for k, v := range m.TagOverrides {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTelemetry(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricsOverrides_TagOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTelemetry(uint64(m.Operation))
	}
	l = len(m.Expression)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessLogging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Telemetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Telemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Telemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracing = append(m.Tracing, &Tracing{})
			if err := m.Tracing[len(m.Tracing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLogging = append(m.AccessLogging, &AccessLogging{})
			if err := m.AccessLogging[len(m.AccessLogging)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSamplingPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSamplingPercentage == nil {
				m.RandomSamplingPercentage = &types.DoubleValue{}
			}
			if err := m.RandomSamplingPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSpanReporting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisableSpanReporting == nil {
				m.DisableSpanReporting = &types.BoolValue{}
			}
			if err := m.DisableSpanReporting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomTags == nil {
				m.CustomTags = make(map[string]*Tracing_CustomTag)
			}
			var mapkey string
			var mapvalue *Tracing_CustomTag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTelemetry
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tracing_CustomTag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomTags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Literal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Literal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Environment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Environment{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_RequestHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Header{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Literal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Literal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Literal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Environment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Environment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Environment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overrides = append(m.Overrides, &MetricsOverrides{})
			if err := m.Overrides[len(m.Overrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsOverrides) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsOverrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsOverrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v MetricsOverrides_StandardMetric
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= MetricsOverrides_StandardMetric(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Metrics = append(m.Metrics, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTelemetry
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Metrics) == 0 {
					m.Metrics = make([]MetricsOverrides_StandardMetric, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v MetricsOverrides_StandardMetric
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= MetricsOverrides_StandardMetric(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Metrics = append(m.Metrics, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficMatch", wireType)
			}
			m.TrafficMatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficMatch |= MetricsOverrides_TrafficMatch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disabled == nil {
				m.Disabled = &types.BoolValue{}
			}
			if err := m.Disabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TagOverrides == nil {
				m.TagOverrides = make(map[string]*MetricsOverrides_TagOverride)
			}
			var mapkey string
			var mapvalue *MetricsOverrides_TagOverride
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTelemetry
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MetricsOverrides_TagOverride{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TagOverrides[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsOverrides_TagOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= MetricsOverrides_TagOverride_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disabled == nil {
				m.Disabled = &types.BoolValue{}
			}
			if err := m.Disabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)
