// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry/v1alpha1/telemetry.proto

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	v1beta1 "istio.io/api/type/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TrafficDirection selects for traffic relative to the local
// proxy.
type TelemetryRuleMatch_TrafficDirection int32

const (
	// (Default) Match all traffic, regardless of direction.
	TelemetryRuleMatch_ALL_DIRECTIONS TelemetryRuleMatch_TrafficDirection = 0
	// Match outbound traffic leaving the proxy. Use this to select "client-side"
	// traffic in telemetry reporting.
	// Note: Use OUTBOUND for gateways (even including ingress)
	TelemetryRuleMatch_OUTBOUND TelemetryRuleMatch_TrafficDirection = 1
	// Match incoming traffic for the proxy. Use this to select "server-side"
	// traffic in telemetry reporting.
	TelemetryRuleMatch_INBOUND TelemetryRuleMatch_TrafficDirection = 2
)

var TelemetryRuleMatch_TrafficDirection_name = map[int32]string{
	0: "ALL_DIRECTIONS",
	1: "OUTBOUND",
	2: "INBOUND",
}

var TelemetryRuleMatch_TrafficDirection_value = map[string]int32{
	"ALL_DIRECTIONS": 0,
	"OUTBOUND":       1,
	"INBOUND":        2,
}

func (x TelemetryRuleMatch_TrafficDirection) String() string {
	return proto.EnumName(TelemetryRuleMatch_TrafficDirection_name, int32(x))
}

func (TelemetryRuleMatch_TrafficDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{3, 0}
}

type TelemetryRuleMatch_Protocol int32

const (
	TelemetryRuleMatch_ALL_PROTOCOLS TelemetryRuleMatch_Protocol = 0
	TelemetryRuleMatch_HTTP          TelemetryRuleMatch_Protocol = 1
	TelemetryRuleMatch_TCP           TelemetryRuleMatch_Protocol = 2
)

var TelemetryRuleMatch_Protocol_name = map[int32]string{
	0: "ALL_PROTOCOLS",
	1: "HTTP",
	2: "TCP",
}

var TelemetryRuleMatch_Protocol_value = map[string]int32{
	"ALL_PROTOCOLS": 0,
	"HTTP":          1,
	"TCP":           2,
}

func (x TelemetryRuleMatch_Protocol) String() string {
	return proto.EnumName(TelemetryRuleMatch_Protocol_name, int32(x))
}

func (TelemetryRuleMatch_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{3, 1}
}

// Curated list of known metric types that Istio expects every Metrics
// extension to be able to generate.
type MetricsOverrides_StandardMetric int32

const (
	MetricsOverrides_ALL                    MetricsOverrides_StandardMetric = 0
	MetricsOverrides_REQUEST_COUNT          MetricsOverrides_StandardMetric = 1
	MetricsOverrides_REQUEST_DURATION       MetricsOverrides_StandardMetric = 2
	MetricsOverrides_REQUEST_SIZE           MetricsOverrides_StandardMetric = 3
	MetricsOverrides_RESPONSE_SIZE          MetricsOverrides_StandardMetric = 4
	MetricsOverrides_TCP_OPEN_CONNECTIONS   MetricsOverrides_StandardMetric = 5
	MetricsOverrides_TCP_CLOSED_CONNECTIONS MetricsOverrides_StandardMetric = 6
	MetricsOverrides_TCP_SENT_BYTES         MetricsOverrides_StandardMetric = 7
	MetricsOverrides_TCP_RECEIVED_BYTES     MetricsOverrides_StandardMetric = 8
	MetricsOverrides_GRPC_REQUEST_MESSAGES  MetricsOverrides_StandardMetric = 9
	MetricsOverrides_GRPC_RESPONSE_MESSAGES MetricsOverrides_StandardMetric = 10
)

var MetricsOverrides_StandardMetric_name = map[int32]string{
	0:  "ALL",
	1:  "REQUEST_COUNT",
	2:  "REQUEST_DURATION",
	3:  "REQUEST_SIZE",
	4:  "RESPONSE_SIZE",
	5:  "TCP_OPEN_CONNECTIONS",
	6:  "TCP_CLOSED_CONNECTIONS",
	7:  "TCP_SENT_BYTES",
	8:  "TCP_RECEIVED_BYTES",
	9:  "GRPC_REQUEST_MESSAGES",
	10: "GRPC_RESPONSE_MESSAGES",
}

var MetricsOverrides_StandardMetric_value = map[string]int32{
	"ALL":                    0,
	"REQUEST_COUNT":          1,
	"REQUEST_DURATION":       2,
	"REQUEST_SIZE":           3,
	"RESPONSE_SIZE":          4,
	"TCP_OPEN_CONNECTIONS":   5,
	"TCP_CLOSED_CONNECTIONS": 6,
	"TCP_SENT_BYTES":         7,
	"TCP_RECEIVED_BYTES":     8,
	"GRPC_REQUEST_MESSAGES":  9,
	"GRPC_RESPONSE_MESSAGES": 10,
}

func (x MetricsOverrides_StandardMetric) String() string {
	return proto.EnumName(MetricsOverrides_StandardMetric_name, int32(x))
}

func (MetricsOverrides_StandardMetric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{7, 0}
}

// Telemetry defines how the telemetry is generated for workloads within a mesh.
//
// For mesh level configuration, put the resource in root configuration namespace for
// your Istio installation *without* a workload selector.
//
// For any namespace, including the root configuration namespace, it is only valid
// to have a single workload selector-less Telemetry resource.
//
// For resources with a workload selector, it is only valid to have one resource selecting
// any given workload.
//
// Telemetry configuration will use a "shallow merge" semantic for configuration override
// for each telemetry type (Tracing, Metrics, AccessLogging). For example, Tracing configuration
// will support overrides of the fields `providers`, `random_sampling_percentage`, `disable_span_reporting`,
// and `custom_tags` at each level in the configuration hierarchy, with missing values filled in
// from parent resources. However, when specified, fields like `custom_tags` will
// fully replace any values provided by parent configuration.
//
// The hierarchy of Telemetry configuration is as follows:
// 1. Workload-specific configuration
// 1. Namespace-specific configuration
// 1. Root namespace configuration
//
// WARNING: Support for Telemetry policies is under active development and is *not*
// stable or supported by Istio at this time.
//
// Examples:
//
// Policy to enable random sampling for 10% of traffic:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   tracing:
//   - randomSamplingPercentage: 10.00
// ```
//
// Policy to disable trace reporting for the "foo" workload (note: tracing
// context will still be propagated):
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing
//   namespace: bar
// spec:
//   selector:
//     labels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - disableSpanReporting: true
// ```
//
// Policy to select the alternate zipkin provider for trace reporting:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing-alternate
//   namespace: baz
// spec:
//   selector:
//     labels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - providers:
//     - name: "zipkin-alternate"
//     randomSamplingPercentage: 10.00
// ```
//
// Policy to add a custom tag from a literal value:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   tracing:
//   - randomSamplingPercentage: 10.00
//     customTags:
//       my_new_foo_tag:
//         literal:
//           value: "foo"
// ```
//
// <!-- crd generation tags
// +cue-gen:Telemetry:groupName:telemetry.istio.io
// +cue-gen:Telemetry:version:v1alpha1
// +cue-gen:Telemetry:storageVersion
// +cue-gen:Telemetry:annotations:helm.sh/resource-policy=keep
// +cue-gen:Telemetry:labels:app=istio-pilot,chart=istio,istio=telemetry,heritage=Tiller,release=istio
// +cue-gen:Telemetry:subresource:status
// +cue-gen:Telemetry:scope:Namespaced
// +cue-gen:Telemetry:resource:categories=istio-io,telemetry-istio-io,shortNames=telemetry,plural=telemetries
// +cue-gen:Telemetry:preserveUnknownFields:false
// +cue-gen:Telemetry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
// representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
// Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=telemetry.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Telemetry struct {
	// Optional. The selector decides where to apply the Telemetry policy.
	// If not set, the Telemetry policy will be applied to all workloads in the
	// same namespace as the Telemetry policy.
	Selector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Optional. Tracing configures the tracing behavior for all
	// selected workloads.
	Tracing []*Tracing `protobuf:"bytes,2,rep,name=tracing,proto3" json:"tracing,omitempty"`
	// Optional. Metrics configures the metrics behavior for all
	// selected workloads.
	Metrics              []*Metrics `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Telemetry) Reset()         { *m = Telemetry{} }
func (m *Telemetry) String() string { return proto.CompactTextString(m) }
func (*Telemetry) ProtoMessage()    {}
func (*Telemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{0}
}
func (m *Telemetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Telemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Telemetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Telemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Telemetry.Merge(m, src)
}
func (m *Telemetry) XXX_Size() int {
	return m.Size()
}
func (m *Telemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_Telemetry.DiscardUnknown(m)
}

var xxx_messageInfo_Telemetry proto.InternalMessageInfo

func (m *Telemetry) GetSelector() *v1beta1.WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *Telemetry) GetTracing() []*Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *Telemetry) GetMetrics() []*Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Tracing configures tracing behavior for workloads within a mesh.
// It can be used to enable/disable tracing, as well as to set sampling
// rates and custom tag extraction.
type Tracing struct {
	// Optional. Name of provider(s) to use for span reporting. If a provider is
	// not specified, the [default tracing provider][istio.mesh.v1alpha1.MeshConfig.default_tracing_provider]
	// will be used.
	// NOTE: At the moment, only a single provider can be specified in a given
	// Tracing rule.
	Providers []*ProviderRef `protobuf:"bytes,2,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls the rate at which traffic will be selected for tracing if no
	// prior sampling decision has been made. If a prior sampling decision has been
	// made, that decision will be respected. However, if no sampling decision
	// has been made (example: no `x-b3-sampled` tracing header was present in the
	// requests), the traffic will be selected for telemetry generation at the
	// percentage specified.
	//
	// Defaults to 0%. Valid values [0.00-100.00]. Can be specified in 0.01%
	// increments.
	RandomSamplingPercentage *types.DoubleValue `protobuf:"bytes,3,opt,name=random_sampling_percentage,json=randomSamplingPercentage,proto3" json:"random_sampling_percentage,omitempty"`
	// Controls span reporting. If set to true, no spans will be reported for
	// impacted workloads. This does NOT impact context propagation or trace
	// sampling behavior.
	DisableSpanReporting *types.BoolValue `protobuf:"bytes,4,opt,name=disable_span_reporting,json=disableSpanReporting,proto3" json:"disable_span_reporting,omitempty"`
	// Optional. Configures additional custom tags to the generated trace spans.
	CustomTags           map[string]*Tracing_CustomTag `protobuf:"bytes,5,rep,name=custom_tags,json=customTags,proto3" json:"custom_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Tracing) Reset()         { *m = Tracing{} }
func (m *Tracing) String() string { return proto.CompactTextString(m) }
func (*Tracing) ProtoMessage()    {}
func (*Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1}
}
func (m *Tracing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing.Merge(m, src)
}
func (m *Tracing) XXX_Size() int {
	return m.Size()
}
func (m *Tracing) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing proto.InternalMessageInfo

func (m *Tracing) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Tracing) GetRandomSamplingPercentage() *types.DoubleValue {
	if m != nil {
		return m.RandomSamplingPercentage
	}
	return nil
}

func (m *Tracing) GetDisableSpanReporting() *types.BoolValue {
	if m != nil {
		return m.DisableSpanReporting
	}
	return nil
}

func (m *Tracing) GetCustomTags() map[string]*Tracing_CustomTag {
	if m != nil {
		return m.CustomTags
	}
	return nil
}

// CustomTag defines a tag to be added to a trace span that is based on
// an operator-supplied value. This value can either be a hard-coded value,
// a value taken from an environment variable known to the sidecar proxy, or
// from a request header.
type Tracing_CustomTag struct {
	// Types that are valid to be assigned to Type:
	//	*Tracing_CustomTag_Literal
	//	*Tracing_CustomTag_Environment
	//	*Tracing_CustomTag_Header
	Type                 isTracing_CustomTag_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Tracing_CustomTag) Reset()         { *m = Tracing_CustomTag{} }
func (m *Tracing_CustomTag) String() string { return proto.CompactTextString(m) }
func (*Tracing_CustomTag) ProtoMessage()    {}
func (*Tracing_CustomTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 0}
}
func (m *Tracing_CustomTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_CustomTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_CustomTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_CustomTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_CustomTag.Merge(m, src)
}
func (m *Tracing_CustomTag) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_CustomTag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_CustomTag.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_CustomTag proto.InternalMessageInfo

type isTracing_CustomTag_Type interface {
	isTracing_CustomTag_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Tracing_CustomTag_Literal struct {
	Literal *Tracing_Literal `protobuf:"bytes,1,opt,name=literal,proto3,oneof" json:"literal,omitempty"`
}
type Tracing_CustomTag_Environment struct {
	Environment *Tracing_Environment `protobuf:"bytes,2,opt,name=environment,proto3,oneof" json:"environment,omitempty"`
}
type Tracing_CustomTag_Header struct {
	Header *Tracing_RequestHeader `protobuf:"bytes,3,opt,name=header,proto3,oneof" json:"header,omitempty"`
}

func (*Tracing_CustomTag_Literal) isTracing_CustomTag_Type()     {}
func (*Tracing_CustomTag_Environment) isTracing_CustomTag_Type() {}
func (*Tracing_CustomTag_Header) isTracing_CustomTag_Type()      {}

func (m *Tracing_CustomTag) GetType() isTracing_CustomTag_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Tracing_CustomTag) GetLiteral() *Tracing_Literal {
	if x, ok := m.GetType().(*Tracing_CustomTag_Literal); ok {
		return x.Literal
	}
	return nil
}

func (m *Tracing_CustomTag) GetEnvironment() *Tracing_Environment {
	if x, ok := m.GetType().(*Tracing_CustomTag_Environment); ok {
		return x.Environment
	}
	return nil
}

func (m *Tracing_CustomTag) GetHeader() *Tracing_RequestHeader {
	if x, ok := m.GetType().(*Tracing_CustomTag_Header); ok {
		return x.Header
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Tracing_CustomTag) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Tracing_CustomTag_Literal)(nil),
		(*Tracing_CustomTag_Environment)(nil),
		(*Tracing_CustomTag_Header)(nil),
	}
}

type Tracing_Literal struct {
	// The tag value to use.
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Literal) Reset()         { *m = Tracing_Literal{} }
func (m *Tracing_Literal) String() string { return proto.CompactTextString(m) }
func (*Tracing_Literal) ProtoMessage()    {}
func (*Tracing_Literal) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 1}
}
func (m *Tracing_Literal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Literal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Literal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Literal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Literal.Merge(m, src)
}
func (m *Tracing_Literal) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Literal) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Literal.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Literal proto.InternalMessageInfo

func (m *Tracing_Literal) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Tracing_Environment struct {
	// Name of the environment variable from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the environment variable is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Environment) Reset()         { *m = Tracing_Environment{} }
func (m *Tracing_Environment) String() string { return proto.CompactTextString(m) }
func (*Tracing_Environment) ProtoMessage()    {}
func (*Tracing_Environment) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 2}
}
func (m *Tracing_Environment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Environment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Environment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Environment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Environment.Merge(m, src)
}
func (m *Tracing_Environment) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Environment) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Environment.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Environment proto.InternalMessageInfo

func (m *Tracing_Environment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_Environment) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

type Tracing_RequestHeader struct {
	// Name of the header from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the header is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_RequestHeader) Reset()         { *m = Tracing_RequestHeader{} }
func (m *Tracing_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*Tracing_RequestHeader) ProtoMessage()    {}
func (*Tracing_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 3}
}
func (m *Tracing_RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_RequestHeader.Merge(m, src)
}
func (m *Tracing_RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_RequestHeader proto.InternalMessageInfo

func (m *Tracing_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_RequestHeader) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

// MetricsRule defines how metrics should be reported and under what conditions
// the reporting should be conducted.
type MetricsRule struct {
	// Defines the conditions under which the associated configuration applies.
	Match *TelemetryRuleMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Customization of the default behavior for metrics.
	Config               *Metrics `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricsRule) Reset()         { *m = MetricsRule{} }
func (m *MetricsRule) String() string { return proto.CompactTextString(m) }
func (*MetricsRule) ProtoMessage()    {}
func (*MetricsRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{2}
}
func (m *MetricsRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsRule.Merge(m, src)
}
func (m *MetricsRule) XXX_Size() int {
	return m.Size()
}
func (m *MetricsRule) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsRule.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsRule proto.InternalMessageInfo

func (m *MetricsRule) GetMatch() *TelemetryRuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *MetricsRule) GetConfig() *Metrics {
	if m != nil {
		return m.Config
	}
	return nil
}

// TelemetryRuleMatch defines conditions for selecting subsets of mesh traffic
// for a workload. TelemetryRuleMatch is concerned with simplified selection
// based on listener, protocol, and traffic direction.
type TelemetryRuleMatch struct {
	// Optional. Specifies the intended direction of the traffic relative to the local proxy.
	// Defaults to ALL if unset.
	TrafficDirection TelemetryRuleMatch_TrafficDirection `protobuf:"varint,1,opt,name=traffic_direction,json=trafficDirection,proto3,enum=istio.telemetry.v1alpha1.TelemetryRuleMatch_TrafficDirection" json:"traffic_direction,omitempty"`
	// Optional. Specifies the protocol of the traffic being monitored.
	Protocol TelemetryRuleMatch_Protocol `protobuf:"varint,2,opt,name=protocol,proto3,enum=istio.telemetry.v1alpha1.TelemetryRuleMatch_Protocol" json:"protocol,omitempty"`
	// Optional. The port on which the traffic is received.
	// Defaults to ALL if unset.
	Port                 *Port    `protobuf:"bytes,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TelemetryRuleMatch) Reset()         { *m = TelemetryRuleMatch{} }
func (m *TelemetryRuleMatch) String() string { return proto.CompactTextString(m) }
func (*TelemetryRuleMatch) ProtoMessage()    {}
func (*TelemetryRuleMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{3}
}
func (m *TelemetryRuleMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryRuleMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryRuleMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryRuleMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryRuleMatch.Merge(m, src)
}
func (m *TelemetryRuleMatch) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryRuleMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryRuleMatch.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryRuleMatch proto.InternalMessageInfo

func (m *TelemetryRuleMatch) GetTrafficDirection() TelemetryRuleMatch_TrafficDirection {
	if m != nil {
		return m.TrafficDirection
	}
	return TelemetryRuleMatch_ALL_DIRECTIONS
}

func (m *TelemetryRuleMatch) GetProtocol() TelemetryRuleMatch_Protocol {
	if m != nil {
		return m.Protocol
	}
	return TelemetryRuleMatch_ALL_PROTOCOLS
}

func (m *TelemetryRuleMatch) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

// Port specifies the number of a port to be used for
// matching or selection for final routing.
type Port struct {
	// Valid port number
	Number               uint32   `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// Used to bind Telemetry configuration to specific providers for
// targeted customization.
type ProviderRef struct {
	// Required. Name of Telemetry provider in MeshConfig.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProviderRef) Reset()         { *m = ProviderRef{} }
func (m *ProviderRef) String() string { return proto.CompactTextString(m) }
func (*ProviderRef) ProtoMessage()    {}
func (*ProviderRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{5}
}
func (m *ProviderRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderRef.Merge(m, src)
}
func (m *ProviderRef) XXX_Size() int {
	return m.Size()
}
func (m *ProviderRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderRef.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderRef proto.InternalMessageInfo

func (m *ProviderRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Metrics defines the workload-level overrides for monitoring behavior within
// a mesh. It can be used to enable/disable metrics generation, as well as to
// customize the shape of the generated metrics.
type Metrics struct {
	// (Optional) Name of providers to which this configuration should apply.
	// If not specified, this will apply to the full list of known metrics
	// providers.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Set of overrides to apply. These include customization of dimensions
	// as well as enablement control.
	Overrides []*MetricsOverrides `protobuf:"bytes,2,rep,name=overrides,proto3" json:"overrides,omitempty"`
	// Optional. Enable to configure the use of HTTP headers to provide values for
	// destination services in telemetry if the metadata has not been supplied by
	// the control plane. This should be enabled with caution, especially at
	// ingress, as it can lead to incorrect/surprising results.
	EnableHostHeaderFallback bool `protobuf:"varint,3,opt,name=enable_host_header_fallback,json=enableHostHeaderFallback,proto3" json:"enable_host_header_fallback,omitempty"`
	// Optional. Controls how frequently metrics for TCP connections are updated. This allows
	// reporting of bytes transferred at intervals for long-lived TCP connections.
	// Defaults to `15s`.
	TcpReportingDuration *types.Duration `protobuf:"bytes,4,opt,name=tcp_reporting_duration,json=tcpReportingDuration,proto3" json:"tcp_reporting_duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{6}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Metrics) GetOverrides() []*MetricsOverrides {
	if m != nil {
		return m.Overrides
	}
	return nil
}

func (m *Metrics) GetEnableHostHeaderFallback() bool {
	if m != nil {
		return m.EnableHostHeaderFallback
	}
	return false
}

func (m *Metrics) GetTcpReportingDuration() *types.Duration {
	if m != nil {
		return m.TcpReportingDuration
	}
	return nil
}

// MetricsOverrides defines custom monitoring behavior for an individual metric
// or the set of all standard metrics.
type MetricsOverrides struct {
	// (Optional) if not specified, config applied to all metrics.
	Metric MetricsOverrides_StandardMetric `protobuf:"varint,1,opt,name=metric,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_StandardMetric" json:"metric,omitempty"`
	// (Optional) Must explicitly set this to "true" to turn off collection.
	SkipReporting bool `protobuf:"varint,2,opt,name=skip_reporting,json=skipReporting,proto3" json:"skip_reporting,omitempty"`
	// (Optional) Collection of tag names and tag expressions to include in the
	// metric. Conflicts are resolved by the tag name by overriding previously
	// supplied values.
	// WARNING: some providers may not support adding custom dimensions.
	Dimensions map[string]string `protobuf:"bytes,3,rep,name=dimensions,proto3" json:"dimensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// (Optional) A list of tags to remove.
	// WARNING: may not be supported by some providers.
	TagsToRemove         []string `protobuf:"bytes,4,rep,name=tags_to_remove,json=tagsToRemove,proto3" json:"tags_to_remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricsOverrides) Reset()         { *m = MetricsOverrides{} }
func (m *MetricsOverrides) String() string { return proto.CompactTextString(m) }
func (*MetricsOverrides) ProtoMessage()    {}
func (*MetricsOverrides) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{7}
}
func (m *MetricsOverrides) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsOverrides) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsOverrides.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsOverrides) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsOverrides.Merge(m, src)
}
func (m *MetricsOverrides) XXX_Size() int {
	return m.Size()
}
func (m *MetricsOverrides) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsOverrides.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsOverrides proto.InternalMessageInfo

func (m *MetricsOverrides) GetMetric() MetricsOverrides_StandardMetric {
	if m != nil {
		return m.Metric
	}
	return MetricsOverrides_ALL
}

func (m *MetricsOverrides) GetSkipReporting() bool {
	if m != nil {
		return m.SkipReporting
	}
	return false
}

func (m *MetricsOverrides) GetDimensions() map[string]string {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *MetricsOverrides) GetTagsToRemove() []string {
	if m != nil {
		return m.TagsToRemove
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.telemetry.v1alpha1.TelemetryRuleMatch_TrafficDirection", TelemetryRuleMatch_TrafficDirection_name, TelemetryRuleMatch_TrafficDirection_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.TelemetryRuleMatch_Protocol", TelemetryRuleMatch_Protocol_name, TelemetryRuleMatch_Protocol_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricsOverrides_StandardMetric", MetricsOverrides_StandardMetric_name, MetricsOverrides_StandardMetric_value)
	proto.RegisterType((*Telemetry)(nil), "istio.telemetry.v1alpha1.Telemetry")
	proto.RegisterType((*Tracing)(nil), "istio.telemetry.v1alpha1.Tracing")
	proto.RegisterMapType((map[string]*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTagsEntry")
	proto.RegisterType((*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTag")
	proto.RegisterType((*Tracing_Literal)(nil), "istio.telemetry.v1alpha1.Tracing.Literal")
	proto.RegisterType((*Tracing_Environment)(nil), "istio.telemetry.v1alpha1.Tracing.Environment")
	proto.RegisterType((*Tracing_RequestHeader)(nil), "istio.telemetry.v1alpha1.Tracing.RequestHeader")
	proto.RegisterType((*MetricsRule)(nil), "istio.telemetry.v1alpha1.MetricsRule")
	proto.RegisterType((*TelemetryRuleMatch)(nil), "istio.telemetry.v1alpha1.TelemetryRuleMatch")
	proto.RegisterType((*Port)(nil), "istio.telemetry.v1alpha1.Port")
	proto.RegisterType((*ProviderRef)(nil), "istio.telemetry.v1alpha1.ProviderRef")
	proto.RegisterType((*Metrics)(nil), "istio.telemetry.v1alpha1.Metrics")
	proto.RegisterType((*MetricsOverrides)(nil), "istio.telemetry.v1alpha1.MetricsOverrides")
	proto.RegisterMapType((map[string]string)(nil), "istio.telemetry.v1alpha1.MetricsOverrides.DimensionsEntry")
}

func init() {
	proto.RegisterFile("telemetry/v1alpha1/telemetry.proto", fileDescriptor_991c84745e2b7651)
}

var fileDescriptor_991c84745e2b7651 = []byte{
	// 1168 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x36, 0x25, 0x59, 0x97, 0xa3, 0xd8, 0x61, 0x06, 0xfe, 0x0d, 0x45, 0xf9, 0xe1, 0x24, 0x6a,
	0x02, 0xa4, 0x97, 0x48, 0xb5, 0x8b, 0x02, 0x4d, 0x8a, 0x00, 0xb5, 0x25, 0x26, 0x32, 0xa0, 0x88,
	0xf2, 0x90, 0x4e, 0x51, 0x6f, 0x88, 0x11, 0x35, 0x92, 0x19, 0x53, 0x1c, 0x76, 0x38, 0x52, 0xe1,
	0x5d, 0x1f, 0xa0, 0x0f, 0xd2, 0x37, 0x69, 0x97, 0x79, 0x84, 0x22, 0xcb, 0x3e, 0x41, 0x17, 0x5d,
	0x14, 0x43, 0xce, 0x48, 0xbe, 0x24, 0x71, 0x9c, 0x9d, 0x78, 0xce, 0xf9, 0xbe, 0xf9, 0xe6, 0xcc,
	0xb9, 0x08, 0x1a, 0x82, 0x86, 0x74, 0x4a, 0x05, 0x3f, 0x6d, 0xcd, 0xb7, 0x49, 0x18, 0x1f, 0x93,
	0xed, 0xd6, 0xc2, 0xd4, 0x8c, 0x39, 0x13, 0x0c, 0xd5, 0x82, 0x44, 0x04, 0xac, 0xb9, 0x34, 0xeb,
	0xc8, 0xfa, 0x1d, 0x71, 0x1a, 0xd3, 0xd6, 0x7c, 0x7b, 0x48, 0x05, 0xd9, 0x6e, 0x25, 0x34, 0xa4,
	0xbe, 0x60, 0x3c, 0x83, 0xd5, 0xb7, 0x26, 0x8c, 0x4d, 0x42, 0xda, 0x4a, 0xbf, 0x86, 0xb3, 0x71,
	0xeb, 0x17, 0x4e, 0xe2, 0x98, 0xf2, 0xe4, 0x7d, 0xfe, 0xd1, 0x8c, 0x13, 0x11, 0xb0, 0x28, 0xf3,
	0x37, 0xfe, 0x30, 0xa0, 0xe2, 0xea, 0x33, 0xd1, 0x0f, 0x50, 0xd6, 0xfc, 0x35, 0xe3, 0x9e, 0xf1,
	0xa8, 0xba, 0xf3, 0xa0, 0xa9, 0x74, 0x9d, 0xc6, 0xb4, 0xa9, 0x34, 0x34, 0x7f, 0x64, 0xfc, 0x24,
	0x64, 0x64, 0xe4, 0xa8, 0x58, 0xbc, 0x40, 0xa1, 0xef, 0xa1, 0x24, 0x38, 0xf1, 0x83, 0x68, 0x52,
	0xcb, 0xdd, 0xcb, 0x3f, 0xaa, 0xee, 0xdc, 0x6f, 0xbe, 0xef, 0x62, 0x4d, 0x37, 0x0b, 0xc4, 0x1a,
	0x21, 0xc1, 0x32, 0x24, 0xf0, 0x93, 0x5a, 0xfe, 0x2a, 0xf0, 0xcb, 0x2c, 0x10, 0x6b, 0x44, 0xe3,
	0xef, 0x22, 0x94, 0x14, 0x23, 0x6a, 0x43, 0x25, 0xe6, 0x6c, 0x1e, 0x8c, 0x28, 0x4f, 0x94, 0x8e,
	0x87, 0xef, 0xa7, 0x1a, 0xa8, 0x50, 0x4c, 0xc7, 0x78, 0x89, 0x43, 0x47, 0x50, 0xe7, 0x24, 0x1a,
	0xb1, 0xa9, 0x97, 0x90, 0x69, 0x1c, 0x06, 0xd1, 0xc4, 0x8b, 0x29, 0xf7, 0x69, 0x24, 0xc8, 0x84,
	0xd6, 0xf2, 0x69, 0x7a, 0xfe, 0xdf, 0xcc, 0xf2, 0xdb, 0xd4, 0xf9, 0x6d, 0x76, 0xd8, 0x6c, 0x18,
	0xd2, 0x57, 0x24, 0x9c, 0x51, 0x5c, 0xcb, 0xf0, 0x8e, 0x82, 0x0f, 0x16, 0x68, 0x34, 0x80, 0xcd,
	0x51, 0x90, 0x90, 0x61, 0x48, 0xbd, 0x24, 0x26, 0x91, 0xc7, 0x69, 0xcc, 0xb8, 0x90, 0x59, 0x2b,
	0xa4, 0xbc, 0xf5, 0x4b, 0xbc, 0x7b, 0x8c, 0x85, 0x19, 0xeb, 0x86, 0x42, 0x3a, 0x31, 0x89, 0xb0,
	0xc6, 0x21, 0x0c, 0x55, 0x7f, 0x96, 0x08, 0x36, 0xf5, 0x04, 0x99, 0x24, 0xb5, 0xd5, 0xf4, 0xd2,
	0xdb, 0x57, 0x26, 0xbf, 0xd9, 0x4e, 0x41, 0x2e, 0x99, 0x24, 0x56, 0x24, 0xf8, 0x29, 0x06, 0x7f,
	0x61, 0xa8, 0xff, 0x63, 0x40, 0x65, 0xe1, 0x47, 0x16, 0x94, 0xc2, 0x40, 0x50, 0x4e, 0x42, 0x55,
	0x1b, 0x9f, 0x5f, 0xcd, 0xde, 0xcb, 0x00, 0xdd, 0x15, 0xac, 0xb1, 0xe8, 0x00, 0xaa, 0x34, 0x9a,
	0x07, 0x9c, 0x45, 0x53, 0x1a, 0x89, 0x5a, 0x2e, 0xa5, 0x7a, 0x7c, 0x35, 0x95, 0xb5, 0x04, 0x75,
	0x57, 0xf0, 0x59, 0x0e, 0xb4, 0x0f, 0xc5, 0x63, 0x4a, 0x46, 0x94, 0xab, 0x57, 0x69, 0x5d, 0xcd,
	0x86, 0xe9, 0xcf, 0x33, 0x9a, 0x88, 0x6e, 0x0a, 0xeb, 0xae, 0x60, 0x45, 0xb0, 0x57, 0x84, 0x82,
	0x2c, 0xf5, 0xfa, 0x5d, 0x28, 0x29, 0xed, 0x68, 0x03, 0x56, 0xe7, 0x32, 0xf1, 0xe9, 0xad, 0x2b,
	0x38, 0xfb, 0xa8, 0x3f, 0x87, 0xea, 0x19, 0x45, 0x08, 0x41, 0x21, 0x22, 0x53, 0x1d, 0x93, 0xfe,
	0x46, 0x9f, 0xc1, 0xda, 0x88, 0x8e, 0xc9, 0x2c, 0x14, 0x5e, 0x46, 0x90, 0x4b, 0x9d, 0x37, 0x94,
	0x31, 0x7d, 0xcd, 0x7a, 0x17, 0xd6, 0xce, 0x69, 0xf9, 0x74, 0xa6, 0xd7, 0x70, 0xf3, 0xc2, 0x63,
	0x22, 0x13, 0xf2, 0x27, 0xf4, 0x54, 0x51, 0xc9, 0x9f, 0x68, 0x57, 0x5f, 0x26, 0xcb, 0xfb, 0x97,
	0xd7, 0x28, 0x10, 0x75, 0xf3, 0xa7, 0xb9, 0xef, 0x8c, 0xc6, 0x6f, 0x06, 0x54, 0x75, 0x07, 0xce,
	0x42, 0x8a, 0xf6, 0x60, 0x75, 0x4a, 0x84, 0x7f, 0xac, 0x2a, 0xe3, 0xab, 0x0f, 0xd0, 0x6a, 0x93,
	0xc4, 0xbd, 0x94, 0x18, 0x9c, 0x41, 0xd1, 0x13, 0x28, 0xfa, 0x2c, 0x1a, 0x07, 0x13, 0xa5, 0xed,
	0x23, 0x9a, 0x5f, 0x01, 0x1a, 0xff, 0xe6, 0x00, 0x5d, 0x26, 0x46, 0xaf, 0xe1, 0x96, 0xe0, 0x64,
	0x3c, 0x0e, 0x7c, 0x6f, 0x14, 0x70, 0xea, 0xcb, 0xb9, 0x97, 0x2a, 0x5c, 0xdf, 0x79, 0x76, 0x1d,
	0x85, 0x32, 0x17, 0x92, 0xa5, 0xa3, 0x49, 0xb0, 0x29, 0x2e, 0x58, 0xd0, 0x01, 0x94, 0xd3, 0x5e,
	0xf5, 0x59, 0x98, 0xea, 0x5f, 0xdf, 0xf9, 0xf6, 0x5a, 0x47, 0x0c, 0x14, 0x18, 0x2f, 0x68, 0xd0,
	0x0e, 0x14, 0x64, 0x77, 0xab, 0xa2, 0xde, 0xfa, 0xc0, 0x00, 0x63, 0x5c, 0xe0, 0x34, 0xb6, 0xb1,
	0x0b, 0xe6, 0x45, 0xb1, 0x08, 0xc1, 0xfa, 0x6e, 0xaf, 0xe7, 0x75, 0xf6, 0xb1, 0xd5, 0x76, 0xf7,
	0xed, 0xbe, 0x63, 0xae, 0xa0, 0x1b, 0x50, 0xb6, 0x0f, 0xdd, 0x3d, 0xfb, 0xb0, 0xdf, 0x31, 0x0d,
	0x54, 0x85, 0xd2, 0x7e, 0x3f, 0xfb, 0xc8, 0x35, 0xbe, 0x86, 0xb2, 0x16, 0x83, 0x6e, 0xc1, 0x9a,
	0x84, 0x0e, 0xb0, 0xed, 0xda, 0x6d, 0xbb, 0x27, 0x91, 0x65, 0x28, 0x74, 0x5d, 0x77, 0x60, 0x1a,
	0xa8, 0x04, 0x79, 0xb7, 0x3d, 0x30, 0x73, 0x8d, 0x2d, 0x28, 0x48, 0x09, 0x68, 0x13, 0x8a, 0xd1,
	0x6c, 0x3a, 0xa4, 0xd9, 0xf2, 0x58, 0xc3, 0xea, 0xab, 0x71, 0x1f, 0xaa, 0x67, 0x66, 0xec, 0xbb,
	0x2a, 0xbc, 0xf1, 0x7b, 0x0e, 0x4a, 0xea, 0x55, 0xcf, 0x4f, 0x6f, 0xe3, 0x13, 0xa7, 0x77, 0x17,
	0x2a, 0x6c, 0x4e, 0x39, 0x0f, 0x46, 0x54, 0xaf, 0x80, 0x2f, 0xae, 0x2c, 0x28, 0x5b, 0x23, 0xf0,
	0x12, 0x8c, 0x9e, 0xc1, 0x1d, 0x1a, 0xa5, 0xa3, 0xfa, 0x98, 0x25, 0xc2, 0xcb, 0x06, 0x85, 0x37,
	0x26, 0x61, 0x38, 0x24, 0xfe, 0x49, 0xfa, 0x3a, 0x65, 0x5c, 0xcb, 0x42, 0xba, 0x4c, 0xf7, 0xf1,
	0x73, 0xe5, 0x47, 0x36, 0x6c, 0x0a, 0x3f, 0x5e, 0x4e, 0x78, 0x4f, 0x6f, 0x60, 0x35, 0xea, 0x6f,
	0x5f, 0x5e, 0x21, 0x2a, 0x00, 0x6f, 0x08, 0x3f, 0x5e, 0x4c, 0x78, 0x6d, 0x6d, 0xbc, 0x29, 0x80,
	0x79, 0x51, 0x2f, 0x3a, 0x80, 0x62, 0xb6, 0x08, 0x55, 0x7d, 0x3f, 0xf9, 0xf8, 0xbb, 0x36, 0x1d,
	0x41, 0xa2, 0x11, 0xe1, 0xa3, 0xcc, 0x81, 0x15, 0x11, 0x7a, 0x08, 0xeb, 0xc9, 0x49, 0x70, 0x46,
	0x79, 0x5a, 0xd7, 0x65, 0xbc, 0x26, 0xad, 0xcb, 0xc5, 0x73, 0x04, 0x30, 0x0a, 0xa6, 0x34, 0x4a,
	0x02, 0x16, 0xe9, 0xbd, 0xfd, 0xf4, 0x1a, 0xa7, 0x77, 0x16, 0x60, 0xb5, 0x80, 0x96, 0x6c, 0xe8,
	0x01, 0xac, 0xcb, 0x6d, 0xe6, 0x09, 0xe6, 0x71, 0x3a, 0x65, 0x73, 0x5a, 0x2b, 0xdc, 0xcb, 0xcb,
	0xc1, 0x27, 0xad, 0x2e, 0xc3, 0xa9, 0xad, 0xfe, 0x0c, 0x6e, 0x5e, 0x20, 0x79, 0xc7, 0xe0, 0xdb,
	0x38, 0x3b, 0xf8, 0x2a, 0x67, 0x67, 0xd9, 0xaf, 0x39, 0x58, 0x3f, 0x9f, 0x02, 0x59, 0xd9, 0xbb,
	0xbd, 0x9e, 0xb9, 0x22, 0xeb, 0x1f, 0x5b, 0x07, 0x87, 0x96, 0xe3, 0x7a, 0x6d, 0xfb, 0xb0, 0xef,
	0x9a, 0x06, 0xda, 0x00, 0x53, 0x9b, 0x3a, 0x87, 0x78, 0x57, 0x36, 0x94, 0x99, 0x43, 0x26, 0xdc,
	0xd0, 0x56, 0x67, 0xff, 0xc8, 0x32, 0xf3, 0x19, 0xd4, 0x19, 0xd8, 0x7d, 0xc7, 0xca, 0x4c, 0x05,
	0x54, 0x83, 0x0d, 0xb7, 0x3d, 0xf0, 0xec, 0x81, 0xd5, 0xf7, 0xda, 0x76, 0xbf, 0xaf, 0xdb, 0x71,
	0x15, 0xd5, 0x61, 0x53, 0x7a, 0xda, 0x3d, 0xdb, 0xb1, 0x3a, 0xe7, 0x7c, 0x45, 0xd9, 0xbe, 0xd2,
	0xe7, 0x58, 0x7d, 0xd7, 0xdb, 0xfb, 0xc9, 0xb5, 0x1c, 0xb3, 0x84, 0x36, 0x01, 0x49, 0x1b, 0xb6,
	0xda, 0xd6, 0xfe, 0x2b, 0xab, 0xa3, 0xec, 0x65, 0x74, 0x1b, 0xfe, 0xf7, 0x02, 0x0f, 0xda, 0x9e,
	0xd6, 0xf2, 0xd2, 0x72, 0x9c, 0xdd, 0x17, 0x96, 0x63, 0x56, 0xe4, 0x11, 0xca, 0xa5, 0x44, 0x2d,
	0x7c, 0xb0, 0xf7, 0xf8, 0xcf, 0xb7, 0x5b, 0xc6, 0x9b, 0xb7, 0x5b, 0xc6, 0x5f, 0x6f, 0xb7, 0x8c,
	0xa3, 0xbb, 0xd9, 0xe3, 0x05, 0xac, 0x45, 0xe2, 0xa0, 0x75, 0xf9, 0xbf, 0xeb, 0xb0, 0x98, 0x96,
	0xea, 0x37, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x82, 0xa7, 0xfd, 0x4f, 0xd8, 0x0a, 0x00, 0x00,
}

func (m *Telemetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Telemetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Telemetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tracing) > 0 {
		for iNdEx := len(m.Tracing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tracing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomTags) > 0 {
		for k := range m.CustomTags {
			v := m.CustomTags[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTelemetry(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DisableSpanReporting != nil {
		{
			size, err := m.DisableSpanReporting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RandomSamplingPercentage != nil {
		{
			size, err := m.RandomSamplingPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_CustomTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Literal != nil {
		{
			size, err := m.Literal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Environment != nil {
		{
			size, err := m.Environment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_Literal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_Environment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryRuleMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryRuleMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryRuleMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Protocol != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x10
	}
	if m.TrafficDirection != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TrafficDirection))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Number != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProviderRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TcpReportingDuration != nil {
		{
			size, err := m.TcpReportingDuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EnableHostHeaderFallback {
		i--
		if m.EnableHostHeaderFallback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Overrides) > 0 {
		for iNdEx := len(m.Overrides) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Overrides[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricsOverrides) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsOverrides) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsOverrides) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TagsToRemove) > 0 {
		for iNdEx := len(m.TagsToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TagsToRemove[iNdEx])
			copy(dAtA[i:], m.TagsToRemove[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TagsToRemove[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Dimensions) > 0 {
		for k := range m.Dimensions {
			v := m.Dimensions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SkipReporting {
		i--
		if m.SkipReporting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Metric != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Metric))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Telemetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Tracing) > 0 {
		for _, e := range m.Tracing {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.RandomSamplingPercentage != nil {
		l = m.RandomSamplingPercentage.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DisableSpanReporting != nil {
		l = m.DisableSpanReporting.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.CustomTags) > 0 {
		for k, v := range m.CustomTags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTelemetry(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Literal != nil {
		l = m.Literal.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricsRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryRuleMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficDirection != 0 {
		n += 1 + sovTelemetry(uint64(m.TrafficDirection))
	}
	if m.Protocol != 0 {
		n += 1 + sovTelemetry(uint64(m.Protocol))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovTelemetry(uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Overrides) > 0 {
		for _, e := range m.Overrides {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.EnableHostHeaderFallback {
		n += 2
	}
	if m.TcpReportingDuration != nil {
		l = m.TcpReportingDuration.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricsOverrides) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != 0 {
		n += 1 + sovTelemetry(uint64(m.Metric))
	}
	if m.SkipReporting {
		n += 2
	}
	if len(m.Dimensions) > 0 {
		for k, v := range m.Dimensions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + 1 + len(v) + sovTelemetry(uint64(len(v)))
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if len(m.TagsToRemove) > 0 {
		for _, s := range m.TagsToRemove {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Telemetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Telemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Telemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracing = append(m.Tracing, &Tracing{})
			if err := m.Tracing[len(m.Tracing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSamplingPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSamplingPercentage == nil {
				m.RandomSamplingPercentage = &types.DoubleValue{}
			}
			if err := m.RandomSamplingPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSpanReporting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisableSpanReporting == nil {
				m.DisableSpanReporting = &types.BoolValue{}
			}
			if err := m.DisableSpanReporting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomTags == nil {
				m.CustomTags = make(map[string]*Tracing_CustomTag)
			}
			var mapkey string
			var mapvalue *Tracing_CustomTag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTelemetry
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tracing_CustomTag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomTags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Literal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Literal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Environment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Environment{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_RequestHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Header{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Literal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Literal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Literal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Environment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Environment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Environment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &TelemetryRuleMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Metrics{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryRuleMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryRuleMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryRuleMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficDirection", wireType)
			}
			m.TrafficDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficDirection |= TelemetryRuleMatch_TrafficDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= TelemetryRuleMatch_Protocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &Port{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overrides = append(m.Overrides, &MetricsOverrides{})
			if err := m.Overrides[len(m.Overrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableHostHeaderFallback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableHostHeaderFallback = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpReportingDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpReportingDuration == nil {
				m.TcpReportingDuration = &types.Duration{}
			}
			if err := m.TcpReportingDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsOverrides) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsOverrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsOverrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			m.Metric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metric |= MetricsOverrides_StandardMetric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipReporting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipReporting = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dimensions == nil {
				m.Dimensions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Dimensions[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagsToRemove = append(m.TagsToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)
